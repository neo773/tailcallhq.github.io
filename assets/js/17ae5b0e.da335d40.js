"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[4582],{8406:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>a,metadata:()=>o,toc:()=>c});var n=i(5893),s=i(1151);const a={title:"Introduction",description:"Learn how you can provide granular access to types and fields in GraphQL schema with the help of authentication providers",slug:"/auth",sidebar_position:1},r=void 0,o={id:"auth/introduction",title:"Introduction",description:"Learn how you can provide granular access to types and fields in GraphQL schema with the help of authentication providers",source:"@site/docs/auth/introduction.md",sourceDirName:"auth",slug:"/auth",permalink:"/docs/auth",draft:!1,unlisted:!1,editUrl:"https://github.com/tailcallhq/tailcallhq.github.io/tree/develop/docs/auth/introduction.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Introduction",description:"Learn how you can provide granular access to types and fields in GraphQL schema with the help of authentication providers",slug:"/auth",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Apollo Studio",permalink:"/docs/telemetry/apollo-studio"},next:{title:"Basic Auth",permalink:"/docs/auth/basic-auth"}},l={},c=[{value:"What is Authentication?",id:"what-is-authentication",level:2},{value:"Entity Level Authentication in GraphqQL",id:"entity-level-authentication-in-graphqql",level:3},{value:"Tailcall Authentication",id:"tailcall-authentication",level:2},{value:"Tailcall config",id:"tailcall-config",level:2},{value:"Making test requests",id:"making-test-requests",level:2},{value:"How it works",id:"how-it-works",level:2},{value:"@protected Type",id:"protected-type",level:3},{value:"Mutation",id:"mutation",level:3},{value:"Multiple auth providers",id:"multiple-auth-providers",level:3},{value:"Authentication headers",id:"authentication-headers",level:3}];function h(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"This guide will walk you through entity level authentication in GraphQL and how it could be achieved with Tailcall."}),"\n",(0,n.jsx)(t.h2,{id:"what-is-authentication",children:"What is Authentication?"}),"\n",(0,n.jsx)(t.p,{children:"Authentication is the process of verifying a user's identity before granting access to data. In most modern applications, some information, such as a list of products in an e-commerce application, is accessible to all users without requiring identification. However, personal data, like a user's order history, is accessible to the user who owns that information. Verifying a user's identity to access such personal data is known as authentication."}),"\n",(0,n.jsx)(t.p,{children:"The primary reasons for implementing authentication in an application include:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Protecting User-Specific Data"})," Ensuring that data belonging to a user is not accessible by others."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Security"})," The ability to block users based on certain criteria necessitates identifying them."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Customized User Experiences"})," Delivering personalized experiences based on a user's identity."]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Authentication can be implemented using credential validation mechanisms, such as:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"/docs/auth/basic-auth",children:"Basic Auth"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"/docs/auth/jwt",children:"JWT"})}),"\n",(0,n.jsx)(t.li,{children:"OAuth"}),"\n",(0,n.jsx)(t.li,{children:"API Key"}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"entity-level-authentication-in-graphqql",children:"Entity Level Authentication in GraphqQL"}),"\n",(0,n.jsx)(t.p,{children:"Entity level authentication in GraphQL refers to applying authentication logic to specific entities or types within your GraphQL schema, rather than at the API entry point or resolver level for individual queries or mutations. This approach allows you to control access to particular data types or fields based on the user's authentication status, enabling a more granular and flexible security model."}),"\n",(0,n.jsx)(t.p,{children:"Advantages of this approach:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Flexibility"}),": Tailors security measures to precisely fit the needs of your application, enhancing the protection of sensitive data."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Scalability"}),": Facilitates extending security policies to new entities and fields as your schema expands."]}),"\n",(0,n.jsxs)(t.li,{children:[(0,n.jsx)(t.strong,{children:"Customization"}),": Enables implementing different authentication mechanisms for distinct entities based on their security requirements."]}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"tailcall-authentication",children:"Tailcall Authentication"}),"\n",(0,n.jsx)(t.p,{children:"Tailcall provides a straightforward way to implement entity level authentication in your GraphQL schema. By leveraging custom directives, you can define which entities or fields require authentication to access their data. Tailcall supports multiple authentication providers, such as Basic Auth and JWT, allowing you to choose the authentication mechanism that best suits your application's requirements.\nto know more about how to use it, read the following articles:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"/docs/auth/basic-auth",children:"Basic Auth"})}),"\n",(0,n.jsx)(t.li,{children:(0,n.jsx)(t.a,{href:"/docs/auth/jwt",children:"JWT"})}),"\n"]}),"\n",(0,n.jsx)(t.h2,{id:"tailcall-config",children:"Tailcall config"}),"\n",(0,n.jsx)(t.p,{children:"Enabling support for authentication in Tailcall could be done in two steps:"}),"\n",(0,n.jsxs)(t.ol,{children:["\n",(0,n.jsxs)(t.li,{children:["With the help of ",(0,n.jsxs)(t.a,{href:"/docs/directives/link",children:[(0,n.jsx)(t.code,{children:"@link"})," directive"]})," connect multiple authentication files as you need for different provides. To connect it use either ",(0,n.jsx)(t.a,{href:"/docs/directives/link#htpasswd",children:(0,n.jsx)(t.code,{children:"Htpasswd"})})," or ",(0,n.jsx)(t.a,{href:"/docs/directives/link#jwks",children:(0,n.jsx)(t.code,{children:"Jwks"})})," link type"]}),"\n",(0,n.jsxs)(t.li,{children:["Mark that some type of field requires authentication to be fetched with the help of ",(0,n.jsxs)(t.a,{href:"/docs/directives/protected",children:[(0,n.jsx)(t.code,{children:"@protected"})," directive"]})]}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Your config could look like this now:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-graphql",children:'schema\n  @server(port: 8000, graphiql: true)\n  @upstream(baseURL: "http://jsonplaceholder.typicode.com")\n  #highlight-start\n  @link(id: "auth-basic", type: Htpasswd, src: "htpasswd")\n  @link(id: "auth-jwt", type: Jwks, src: "jwks.json") {\n  #highlight-end\n\n  query: Query\n  mutation: Mutation\n}\n\ntype Query {\n  posts: [Post] @http(path: "/posts")\n  user(id: Int!): User @http(path: "/users/{{.args.id}}")\n}\n\ntype Mutation {\n  user(id: Int!): User @http(path: "/users/{{.args.id}}")\n}\n\n#highlight-start\ntype User @protected {\n  #highlight-end\n  id: Int!\n  name: String!\n  username: String!\n  email: String!\n  phone: String\n  website: String\n}\n\ntype Post {\n  id: Int!\n  userId: Int!\n  title: String!\n  #highlight-start\n  body: String! @protected\n  #highlight-end\n  user: User @http(path: "/users/{{.value.userId}}")\n}\n'})}),"\n",(0,n.jsxs)(t.p,{children:["In that case the whole ",(0,n.jsx)(t.code,{children:"User"})," type and ",(0,n.jsx)(t.code,{children:"Post.body"})," are marked as protected and therefore requiring authentication to resolve its content. That means following points:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsxs)(t.li,{children:["any query for ",(0,n.jsx)(t.code,{children:"Post.body"})," will require authentication"]}),"\n",(0,n.jsxs)(t.li,{children:["any query for any field of ",(0,n.jsx)(t.code,{children:"User"})," will require authentication"]}),"\n",(0,n.jsxs)(t.li,{children:["any field that resolves to ",(0,n.jsx)(t.code,{children:"User"})," type will require authentication"]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["For more info about possible configuration for available providers read articles for ",(0,n.jsx)(t.a,{href:"/docs/auth/basic-auth",children:"Basic Auth"})," and ",(0,n.jsx)(t.a,{href:"/docs/auth/jwt",children:"JWT"})]}),"\n",(0,n.jsx)(t.h2,{id:"making-test-requests",children:"Making test requests"}),"\n",(0,n.jsx)(t.p,{children:"Now let's try to access some data from the example above. Start the tailcall server with provided config and use graphQL playground that should be opened automatically in your browser."}),"\n",(0,n.jsxs)(t.p,{children:["If you execute the query that don't have any ",(0,n.jsx)(t.code,{children:"@protected"})," fields like"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-graphql",children:"{\n  posts {\n    title\n  }\n}\n"})}),"\n",(0,n.jsxs)(t.p,{children:["Then the data for this will be resolved as usual without providing any additional info. showing the list of posts with their titles:\n",(0,n.jsx)(t.img,{alt:"unprotected.png",src:i(2032).Z+"",width:"1728",height:"997"}),"\nBut if you change the query to access protected data, then if you don't provide any authentication data, i.e. for query:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-graphql",children:"{\n  posts {\n    body\n  }\n}\n"})}),"\n",(0,n.jsx)(t.p,{children:"You will get an authentication failure error stating that authentication parameters were not provided. e.g.:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-json",children:'{\n  "data": null,\n  "errors": [\n    {\n      "message": "Authentication Failure: Parameters not provided in the request.",\n      "locations": [\n        {\n          "line": 3,\n          "column": 5\n        }\n      ]\n    }\n  ]\n}\n'})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"protected.png",src:i(5508).Z+"",width:"1728",height:"995"})}),"\n",(0,n.jsxs)(t.p,{children:["Now update the request by providing additional Authorization header. You can do in the Playground by navigating to the tab ",(0,n.jsx)(t.code,{children:"HTTP HEADERS"})," at the bottom by adding following header for Basic Auth:\n",(0,n.jsx)(t.img,{alt:"img.png",src:i(766).Z+"",width:"1728",height:"990"})]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-json",children:'{\n  "Authorization": "Basic dGVzdHVzZXIxOnBhc3N3b3JkMTIzs"\n}\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Now after executing the request again you'll get the response for all the requested fields without any error.\n",(0,n.jsx)(t.img,{alt:"basic_auth.png",src:i(5083).Z+"",width:"1724",height:"977"})]}),"\n",(0,n.jsx)(t.h2,{id:"how-it-works",children:"How it works"}),"\n",(0,n.jsx)(t.h3,{id:"protected-type",children:"@protected Type"}),"\n",(0,n.jsxs)(t.p,{children:["If type is marked with ",(0,n.jsx)(t.code,{children:"@protected"})," then:"]}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"attempt to request any field of that type will require authentication"}),"\n",(0,n.jsx)(t.li,{children:"attempt to request any field from other type that resolves to protected type will require authentication and the underlying IO operation won't be executed without it"}),"\n"]}),"\n",(0,n.jsx)(t.h3,{id:"mutation",children:"Mutation"}),"\n",(0,n.jsxs)(t.p,{children:["For mutation entity level authentication works similar to queries. But since mutation involves requests that changes external state you should be careful where do you specify ",(0,n.jsx)(t.code,{children:"@protected"})," directive because marking some nested field as protected doesn't prevent from executing the request to resolve the parent fields. I.e. following example is problematic:"]}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-graphql",children:'schema {\n  query: Query\n  mutation: Mutation\n}\n\ntype Query {\n  user(id: Int!): User @http(path: "/users/{{.args.id}}")\n}\n\ntype Mutation {\n  user(id: Int!): User\n    @http(path: "/users/{{.args.id}}", method: POST)\n}\n\ntype User {\n  id: Int!\n  name: String!\n  website: String @protected\n}\n'})}),"\n",(0,n.jsxs)(t.p,{children:["Here you can still execute the mutation without any authentication and fail on attempting to resolve ",(0,n.jsx)(t.code,{children:"website"})," field."]}),"\n",(0,n.jsx)(t.p,{children:"To resolve this issue, consider marking root fields as protected in case they require authentication, i.e.:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-graphql",children:'schema {\n  query: Query\n  mutation: Mutation\n}\n\ntype Query {\n  user(id: Int!): User @http(path: "/users/{{.args.id}}")\n}\n\ntype Mutation {\n  user(id: Int!): User\n    @http(path: "/users/{{.args.id}}", method: POST)\n    @protected\n}\n\ntype User {\n  id: Int!\n  name: String!\n  website: String @protected\n}\n'})}),"\n",(0,n.jsx)(t.h3,{id:"multiple-auth-providers",children:"Multiple auth providers"}),"\n",(0,n.jsx)(t.p,{children:"In case you linked multiple authentication files all of them will be used to execute validation process. In that case, by default, Tailcall will validate all of them in parallel and succeed if at least one of them succeed."}),"\n",(0,n.jsx)(t.h3,{id:"authentication-headers",children:"Authentication headers"}),"\n",(0,n.jsxs)(t.p,{children:["To validate authentication for user request the specific headers are used (like ",(0,n.jsx)(t.code,{children:"Authorization"})," header). In case auth is enabled for tailcall those headers will be also added to the ",(0,n.jsxs)(t.a,{href:"/docs/directives/upstream#allowedheaders",children:[(0,n.jsx)(t.code,{children:"allowedHeaders"})," list"]})," and therefore they will be forwarded to the upstream requests implicitly."]})]})}function d(e={}){const{wrapper:t}={...(0,s.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},5083:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/basic_auth-08a98ed75ce837276e42992bfbdf3998.png"},766:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/img-67c7fb98ef74ef8bf388507acb1a521b.png"},5508:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/protected-37cdf6642bafca18cd59c65a8961fcde.png"},2032:(e,t,i)=>{i.d(t,{Z:()=>n});const n=i.p+"assets/images/unprotected-c27f5b8f876d819d963228c5284643cc.png"},1151:(e,t,i)=>{i.d(t,{Z:()=>o,a:()=>r});var n=i(7294);const s={},a=n.createContext(s);function r(e){const t=n.useContext(a);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),n.createElement(a.Provider,{value:t},e.children)}}}]);
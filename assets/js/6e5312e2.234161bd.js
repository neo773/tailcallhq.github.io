"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[9162],{3358:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var s=t(5893),i=t(1151);const r={title:"@call",description:"Using the call directive to enhance GraphQL schemas improving code reusability."},a=void 0,c={id:"directives/call",title:"@call",description:"Using the call directive to enhance GraphQL schemas improving code reusability.",source:"@site/docs/directives/call.md",sourceDirName:"directives",slug:"/directives/call",permalink:"/docs/directives/call",draft:!1,unlisted:!1,editUrl:"https://github.com/tailcallhq/tailcallhq.github.io/tree/develop/docs/directives/call.md",tags:[],version:"current",frontMatter:{title:"@call",description:"Using the call directive to enhance GraphQL schemas improving code reusability."},sidebar:"tutorialSidebar",previous:{title:"@cache",permalink:"/docs/directives/cache"},next:{title:"@const",permalink:"/docs/directives/const"}},o={},l=[{value:"steps",id:"steps",level:2},{value:"query",id:"query",level:3},{value:"mutation",id:"mutation",level:3},{value:"args",id:"args",level:3},{value:"Composition",id:"composition",level:3}];function d(e){const n={a:"a",admonition:"admonition",code:"code",h2:"h2",h3:"h3",p:"p",pre:"pre",strong:"strong",...(0,i.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"@call"})," directive in GraphQL signifies a shift towards more efficient configuration management by introducing a methodology akin to function invocations in conventional programming. This directive is pivotal for developers navigating the intricacies of elaborate GraphQL schemas, where minimizing redundancy and adhering to the DRY (Don't Repeat Yourself) principle are paramount. Consider the following schema example:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:"showLineNumbers",children:'schema\n  @upstream(\n    baseURL: "https://jsonplaceholder.typicode.com"\n  ) {\n  query: Query\n}\n\ntype Query {\n  # highlight-start\n  user(id: Int!): User @http(path: "/users/{{args.id}}")\n  # highlight-end\n  posts: [Post] @http(path: "/posts")\n}\n\ntype Post {\n  id: Int!\n  userId: Int!\n  title: String!\n  body: String!\n  # highlight-start\n  user: User @http(path: "/users/{{value.userId}}")\n  # highlight-end\n}\n\ntype User {\n  id: Int!\n  name: String!\n  email: String!\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["In this schema, at lines ",(0,s.jsx)(n.code,{children:"9"})," and ",(0,s.jsx)(n.code,{children:"18"}),", a pattern of configuration duplication emerges when fetching user's data by its id, demonstrating a prime use case for the ",(0,s.jsx)(n.code,{children:"@call"})," directive. Through refactoring the ",(0,s.jsx)(n.code,{children:"Post"})," type to incorporate the ",(0,s.jsx)(n.code,{children:"@call"})," directive, we can eliminate this redundancy."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:"showLineNumbers",children:'type Post {\n  id: Int!\n  userId: Int!\n  title: String!\n  body: String!\n  # highlight-start\n  user: User\n    @call(\n      steps: [\n        {query: "user", args: {id: "{{value.userId}}"}}\n      ]\n    )\n  # highlight-end\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Here, the ",(0,s.jsx)(n.code,{children:"@call"})," directive invokes the ",(0,s.jsx)(n.code,{children:"user"})," query from the ",(0,s.jsx)(n.code,{children:"Query"})," type, leveraging the data-fetching process that's already defined in the root ",(0,s.jsx)(n.code,{children:"query"}),". The ",(0,s.jsx)(n.code,{children:"query"})," parameter specifies the target field, while the ",(0,s.jsx)(n.code,{children:"args"})," parameter delineates the arguments to be passed."]}),"\n",(0,s.jsx)(n.h2,{id:"steps",children:"steps"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"@call"})," directive can compose together other resolvers, allowing to create a chain of resolvers that can be executed in sequence. This is done by using the ",(0,s.jsx)(n.code,{children:"steps"})," parameter, which is an array of objects that define the operations to be executed."]}),"\n",(0,s.jsx)(n.h3,{id:"query",children:"query"}),"\n",(0,s.jsxs)(n.p,{children:["Specify the root ",(0,s.jsx)(n.strong,{children:"query"})," field to invoke, alongside the requisite arguments, using the ",(0,s.jsx)(n.code,{children:"@call"})," directive for a concise and efficient query structure."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:"showLineNumbers",children:'type Post {\n  userId: Int!\n  user: User\n    @call(\n      steps: [\n        {query: "user", args: {id: "{{value.userId}}"}}\n      ]\n    )\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"mutation",children:"mutation"}),"\n",(0,s.jsxs)(n.p,{children:["Similarly, the ",(0,s.jsx)(n.code,{children:"@call"})," directive can facilitate calling a mutation from another mutation field, employing the ",(0,s.jsx)(n.code,{children:"mutation"})," parameter for field specification and the ",(0,s.jsx)(n.code,{children:"args"})," parameter for argument delineation."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:"showLineNumbers",children:'type Mutation {\n  insertPost(input: PostInput, overwrite: Boolean): Post\n    @http(\n      body: "{{args.input}}"\n      method: "POST"\n      path: "/posts"\n      query: {overwrite: "{{args.overwrite}}"}\n    )\n\n  upsertPost(input: PostInput): Post\n    @call(\n      steps: [\n        {\n          mutation: "insertPost"\n          args: {input: "{{args.input}}", overwrite: true}\n        }\n      ]\n    )\n}\n'})}),"\n",(0,s.jsx)(n.h3,{id:"args",children:"args"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"args"})," parameter in the ",(0,s.jsx)(n.code,{children:"@call"})," directive facilitates passing arguments to the targeted query or mutation, represented as a key-value mapping where each key corresponds to an argument name and its associated value."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:"showLineNumbers",children:'type Post {\n  userId: Int!\n  user: User\n    @call(\n      steps: [\n        {query: "user", args: {id: "{{value.userId}}"}}\n      ]\n    )\n}\n'})}),"\n",(0,s.jsx)(n.admonition,{type:"tip",children:(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"@call"})," directive is predominantly advantageous in complex, large-scale configurations. For those new to GraphQL or Tailcall, it may be beneficial to explore this directive after familiarizing yourself with the foundational aspects of GraphQL."]})}),"\n",(0,s.jsx)(n.h3,{id:"composition",children:"Composition"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.code,{children:"@call"})," directive provides the ability to express a sequence of steps that one might need to compose. These steps are executed such that the result of each step is passed as an argument to the next step. The ",(0,s.jsx)(n.code,{children:"query"})," and ",(0,s.jsx)(n.code,{children:"mutation"})," parameters are used to specify the target field, while the ",(0,s.jsx)(n.code,{children:"args"})," parameter is used to pass arguments to the target field."]}),"\n",(0,s.jsx)(n.p,{children:"Let's explain this with an example:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:"showLineNumbers",children:'schema @server(graphiql: true) {\n  query: Query\n}\n\ntype Query {\n  a(input: JSON): JSON\n    @const(data: {value: "{{args.input.a}}"})\n\n  b(input: JSON): JSON\n    @const(data: {value: "{{args.input.b}}"})\n\n  c(input: JSON): JSON\n    @const(data: {value: "{{args.input.c}}"})\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Here we have defined there operations viz. ",(0,s.jsx)(n.code,{children:"a"}),", ",(0,s.jsx)(n.code,{children:"b"})," & ",(0,s.jsx)(n.code,{children:"c"})," each of them pluck their respective keys from the given input value. Let's run this query with some test input:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"{\n  a(input: {a: 100})\n  b(input: {b: 200})\n  c(input: {c: 300})\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"Here is how the response would look like:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "data": {\n    "a": {\n      "value": 100\n    },\n    "b": {\n      "value": 200\n    },\n    "c": {\n      "value": 300\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["As you can see the ",(0,s.jsx)(n.a,{href:"/docs/directives/const",children:(0,s.jsx)(n.code,{children:"@const"})})," directive plucks the inner value and returns the result. How about we implement an ",(0,s.jsx)(n.code,{children:"abc"})," operation that could leverage the existing operations and unwrap the following input value:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{"a": {"b": {"c": {"d": 1000}}}}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["Given the above input if we wish to extract the last inner number ",(0,s.jsx)(n.code,{children:"1000"})," then we could define a new operation as follows"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",metastring:"showLineNumbers",children:'schema @server(graphiql: true) {\n  query: Query\n}\n\ntype Query {\n  a(input: JSON): JSON\n    @const(data: {value: "{{args.input.a}}"})\n\n  b(input: JSON): JSON\n    @const(data: {value: "{{args.input.b}}"})\n\n  c(input: JSON): JSON\n    @const(data: {value: "{{args.input.c}}"})\n\n  # highlight-start\n  abc(input: JSON): JSON\n    @call(\n      steps: [\n        {query: "a", args: {input: "{{args.input}}"}}\n        {query: "b", args: {input: "{{args.value}}"}}\n        {query: "c", args: {input: "{{args.value}}"}}\n      ]\n    )\n  # highlight-end\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["We use the ",(0,s.jsx)(n.code,{children:"@call"})," directive to compose the operations together. The ",(0,s.jsx)(n.code,{children:"args"})," specify how we would like to pass the arguments to the operation and the result of that operation is passed to the next step. We can test the new ",(0,s.jsx)(n.code,{children:"abc"})," operation with the following query:"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-graphql",children:"query {\n  abc(input: {a: {b: {c: 1000}}})\n}\n"})}),"\n",(0,s.jsx)(n.p,{children:"The server returns the response that we expected:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-json",children:'{\n  "data": {\n    "abc": {\n      "value": 100\n    }\n  }\n}\n'})}),"\n",(0,s.jsxs)(n.p,{children:["This way you can compose combine multiple operations can compose them together using the ",(0,s.jsx)(n.code,{children:"@call"})," directive."]}),"\n",(0,s.jsx)(n.admonition,{type:"note",children:(0,s.jsxs)(n.p,{children:["We use ",(0,s.jsx)(n.code,{children:"JSON"})," scalar here because we don't care about the type safety of this option. In a real world example you might want to use proper input and output types."]})})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>c,a:()=>a});var s=t(7294);const i={},r=s.createContext(i);function a(e){const n=s.useContext(r);return s.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);
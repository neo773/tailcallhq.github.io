"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2800],{5529:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>l});var a=n(5893),i=n(1151);const s={title:"Problem Statement",sidebar_position:2,slug:"/"},o=void 0,r={id:"intro/introduction",title:"Problem Statement",description:"Traditional API Gateway",source:"@site/docs/intro/introduction.md",sourceDirName:"intro",slug:"/",permalink:"/docs/",draft:!1,unlisted:!1,editUrl:"https://github.com/tailcallhq/tailcallhq.github.io/tree/develop/docs/intro/introduction.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Problem Statement",sidebar_position:2,slug:"/"},sidebar:"tutorialSidebar",next:{title:"Installation",permalink:"/docs/getting_started"}},c={},l=[{value:"Traditional API Gateway",id:"traditional-api-gateway",level:2},{value:"Tailcall API Gateway",id:"tailcall-api-gateway",level:2}];function d(e){const t={code:"code",h2:"h2",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.h2,{id:"traditional-api-gateway",children:"Traditional API Gateway"}),"\n",(0,a.jsx)(t.p,{children:'Traditional API Gateways ("TAGs") form the backbone of modern web based application architectures, offering a comprehensive suite of features essential for efficient API management. These gateways handle tasks such as routing, authentication, circuit breaking, caching, logging, monitoring, protocol translation and the list doesn\'t end!'}),"\n",(0,a.jsx)(t.p,{children:"API Gateways fail to provide developers with the appropriate abstraction for configuring these capabilities. Typically, a TAG offers primitives based on the underlying protocol (that is, the protocol serving the API). For instance, it allows performing authentication, routing, rate-limiting, etc., based on request headers, URL, or method\u2014all components of the HTTP protocol. This approach occurs because they consider the contents of request and response bodies as simple byte sequences, without examining their actual content."}),"\n",(0,a.jsx)(t.p,{children:"Over the years, we have gotten used to consuming and managing APIs this way. Writing our own custom abstractions and sticking it around an existing over the shelf API Gateway. Our personal experience has been that nearly all companies after a certain scale require an abstraction that's specific to their business entities and feel restricted by what the API Gateway can provide."}),"\n",(0,a.jsx)(t.h2,{id:"tailcall-api-gateway",children:"Tailcall API Gateway"}),"\n",(0,a.jsxs)(t.p,{children:["Based on our learnings of writing APIs at massive scale, we believe that the gateway should work around an enterprise's business entities and not the other way round. That is what Tailcall helps you achieve.\nTailcall provides first-class primitives designed to interact with your business entities directly without burdening the developer with the underlying protocol. This approach grants tremendous power and flexibility, transcending protocol constraints and focusing on the nature of the API's data. Let's take the ",(0,a.jsx)(t.code,{children:"User"})," entity as an example:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-graphql",children:"type User {\n  id: ID\n  name: String\n  email: String\n  account: Account\n}\n\ntype Account {\n  balance: Float\n  lastUpdated: Date\n}\n"})}),"\n",(0,a.jsxs)(t.p,{children:["Distinct APIs can return the ",(0,a.jsx)(t.code,{children:"User"})," business entity. For example, a ",(0,a.jsx)(t.code,{children:"/users"})," API might deliver the ",(0,a.jsx)(t.code,{children:"id"}),", ",(0,a.jsx)(t.code,{children:"name"}),", and ",(0,a.jsx)(t.code,{children:"email"}),", while a ",(0,a.jsx)(t.code,{children:"/accounts/:userId"})," API could supply the account ",(0,a.jsx)(t.code,{children:"balance"})," and ",(0,a.jsx)(t.code,{children:"lastUpdated"})," for a user. Tailcall's API Gateway enables specifying that requests to access account details require authentication, unlike other requests."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-graphql",children:"type User {\n  id: ID\n  name: String\n  email: String\n  account: Account @private\n}\n\ntype Account {\n  balance: Float\n  lastUpdated: Date\n}\n"})}),"\n",(0,a.jsx)(t.p,{children:"With Tailcall, specifying which parts of an entity should be public or private becomes straightforward, the platform also allows for the obfuscation of fields deemed sensitive or PII in specific contexts. This is all achievable through Tailcall's DSL, which facilitates all these complex operations efficiently and with minimal latency."}),"\n",(0,a.jsx)(t.p,{children:"Tailcall's DSL further enhances its capabilities by supporting advanced API Orchestration, moving beyond simple request routing. This feature allows you to outline the desired API structure and guides you in integrating each component within the entity type. For example, consider a transaction API that includes a userId. Traditionally, expanding this userId to access the corresponding user details would involve micro-services. With Tailcall, using its DSL triggers the Tailcall runtime to automatically resolve and populate these details, removing the need for manual coding and making the API management process more efficient."})]})}function h(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},1151:(e,t,n)=>{n.d(t,{Z:()=>r,a:()=>o});var a=n(7294);const i={},s=a.createContext(i);function o(e){const t=a.useContext(s);return a.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);
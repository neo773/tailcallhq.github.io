"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[3106],{9871:(e,t,i)=>{i.r(t),i.d(t,{assets:()=>o,contentTitle:()=>r,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>c});var n=i(4848),s=i(8453);const a={title:"Using Mutability in Tailcall",sidebar_label:"Mutability",description:"Understand and implement mutability in your APIs with Tailcall. Access comprehensive guides to manage state changes effectively."},r=void 0,l={id:"mutability",title:"Using Mutability in Tailcall",description:"Understand and implement mutability in your APIs with Tailcall. Access comprehensive guides to manage state changes effectively.",source:"@site/developers/mutability.md",sourceDirName:".",slug:"/mutability",permalink:"/developers/mutability",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{title:"Using Mutability in Tailcall",sidebar_label:"Mutability",description:"Understand and implement mutability in your APIs with Tailcall. Access comprehensive guides to manage state changes effectively."},sidebar:"tutorialSidebar",previous:{title:"Micro Benchmarks",permalink:"/developers/micro-benchmark"},next:{title:"Telemetry",permalink:"/developers/telemetry"}},o={},c=[{value:"Using References",id:"using-references",level:2},{value:"Using Ownership",id:"using-ownership",level:2},{value:"Using Mutable References",id:"using-mutable-references",level:2},{value:"Exceptions",id:"exceptions",level:2}];function d(e){const t={admonition:"admonition",code:"code",h2:"h2",p:"p",pre:"pre",...(0,s.R)(),...e.components},{Head:i}=t;return i||function(e,t){throw new Error("Expected "+(t?"component":"object")+" `"+e+"` to be defined: you likely forgot to import, pass, or provide it.")}("Head",!0),(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(i,{children:(0,n.jsx)("title",{children:"Mutability For Developers | Tailcall"})}),"\n",(0,n.jsx)(t.p,{children:"Typically you would have a question about an argument being passed as a value vs as a reference specially if you are new to Rust. This is short guide that will help in deciding when to use mutability in the Tailcall codebase."}),"\n",(0,n.jsx)(t.h2,{id:"using-references",children:"Using References"}),"\n",(0,n.jsx)(t.p,{children:"When calling functions that do not need to modify the values they receive, pass references to these values. This avoids unnecessary copying and preserves the original data integrity.\ud83d\udcb0"}),"\n",(0,n.jsx)(t.p,{children:"Consider a function that calculates the total number of items in a list. This function does not alter the list, so pass the list as a reference:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"fn count_items(items: &Vec<i32>) -> usize {\n    items.len()\n}\nlet my_items = vec![1, 2, 3];\nlet total = count_items(&my_items);\n"})}),"\n",(0,n.jsx)(t.h2,{id:"using-ownership",children:"Using Ownership"}),"\n",(0,n.jsx)(t.p,{children:"When calling functions that need to modify the values they receive, pass ownership of these values to the function. This makes it clear that the function might change the value. Ensure that the modified values are returned from the function if further use is required."}),"\n",(0,n.jsx)(t.p,{children:"Consider a function that adds an item to a list. Since this modifies the list, pass the list with ownership and return the modified list:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:"fn add_item(mut items: Vec<i32>, item: i32) -> Vec<i32> {\n    items.push(item);\n    items\n}\nlet my_items = vec![1, 2, 3];\nlet updated_items = add_item(my_items, 4);\n"})}),"\n",(0,n.jsx)(t.h2,{id:"using-mutable-references",children:"Using Mutable References"}),"\n",(0,n.jsx)(t.p,{children:"Mutable references are particularly useful when you need to modify the data a function receives without taking ownership of it. This approach is ideal for types that behave like classical stateful services, where maintaining state across multiple function calls is necessary."}),"\n",(0,n.jsx)(t.p,{children:"Consider a caching mechanism where data needs to be frequently updated or retrieved based on function calls. In this case, using a mutable reference allows the cache to be updated without transferring ownership each time:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-rust",children:'struct Cache {\n    data: HashMap<String, String>,\n}\n\nimpl Cache {\n    fn add_entry(&mut self, key: String, value: String) {\n        self.data.insert(key, value);\n    }\n\n    fn get_entry(&self, key: &str) -> Option<&String> {\n        self.data.get(key)\n    }\n}\n\nlet mut my_cache = Cache { data: HashMap::new() };\nmy_cache.add_entry("session1".to_string(), "User123".to_string());\nif let Some(user) = my_cache.get_entry("session1") {\n    println!("Cached user: {}", user);\n}\n'})}),"\n",(0,n.jsx)(t.admonition,{type:"note",children:(0,n.jsx)(t.p,{children:"Even though in Rust mutability is a lot more tamed than other languages, as a standard we try to stay away from mutable references as much as possible."})}),"\n",(0,n.jsx)(t.h2,{id:"exceptions",children:"Exceptions"}),"\n",(0,n.jsx)(t.p,{children:"The approach outlined above may not be suitable for performance-sensitive components or frequently executed sections of code (hot code paths). In such scenarios, prioritize efficiency and adopt optimization strategies to enhance performance. Sometimes the API design of a dependent library can also influence the way we write code. These are all the exceptions where it's ok to move away from the above set guidelines."})]})}function h(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(d,{...e})}):d(e)}}}]);
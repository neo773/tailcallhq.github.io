"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[5797],{9906:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>o,contentTitle:()=>a,default:()=>h,frontMatter:()=>r,metadata:()=>l,toc:()=>c});var t=s(5893),i=s(1151);const r={title:"N+1 Problem",description:"Discover how to efficiently address the N+1 problem in using Tailcall with our comprehensive guide. Learn to reduce server requests and optimize performance using practical solutions and step-by-step examples with the TailCall CLI for GraphQL applications. Enhance your coding practices and ensure scalable, high-performance web applications by mastering techniques to mitigate the N+1 problem, reduce server load, and improve response times."},a=void 0,l={id:"guides/n+1",title:"N+1 Problem",description:"Discover how to efficiently address the N+1 problem in using Tailcall with our comprehensive guide. Learn to reduce server requests and optimize performance using practical solutions and step-by-step examples with the TailCall CLI for GraphQL applications. Enhance your coding practices and ensure scalable, high-performance web applications by mastering techniques to mitigate the N+1 problem, reduce server load, and improve response times.",source:"@site/docs/guides/n+1.md",sourceDirName:"guides",slug:"/guides/n+1",permalink:"/docs/guides/n+1",draft:!1,unlisted:!1,editUrl:"https://github.com/tailcallhq/tailcallhq.github.io/tree/develop/docs/guides/n+1.md",tags:[],version:"current",frontMatter:{title:"N+1 Problem",description:"Discover how to efficiently address the N+1 problem in using Tailcall with our comprehensive guide. Learn to reduce server requests and optimize performance using practical solutions and step-by-step examples with the TailCall CLI for GraphQL applications. Enhance your coding practices and ensure scalable, high-performance web applications by mastering techniques to mitigate the N+1 problem, reduce server load, and improve response times."},sidebar:"tutorialSidebar",previous:{title:"Logging",permalink:"/docs/guides/logging"},next:{title:"Playground",permalink:"/docs/guides/playground"}},o={},c=[{value:"N + 1 Example",id:"n--1-example",level:2},{value:"N + 1 in Tailcall",id:"n--1-in-tailcall",level:2},{value:"Automatic Deduplication",id:"automatic-deduplication",level:2},{value:"Compile Time N + 1 Checks",id:"compile-time-n--1-checks",level:2},{value:"Leveraging Batch APIs",id:"leveraging-batch-apis",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={a:"a",admonition:"admonition",code:"code",em:"em",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.strong,{children:"N+1 problem"})," significantly impacts systems performance by triggering numerous upstream requests in response to a single downstream request. However, with Tailcall's powerful introspection capabilities, you can identify all instances of N+1 issues even before you start your server. Before we delve deeper into how Tailcall accomplishes this, let's understand the N+1 issue in detail."]}),"\n",(0,t.jsx)(n.h2,{id:"n--1-example",children:"N + 1 Example"}),"\n",(0,t.jsxs)(n.p,{children:["Imagine we need to fetch data from the ",(0,t.jsx)(n.a,{href:"https://jsonplaceholder.typicode.com/",children:"jsonplaceholder.typicode.com"}),", requiring both posts and their authors' details."]}),"\n",(0,t.jsx)(n.p,{children:"First, we request all posts:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'\u276f curl https://jsonplaceholder.typicode.com/posts\n  [\n    {\n      "userId": 1,\n      "id": 1,\n      "title": "Creating Solutions for Challenges",\n      "body": "We anticipate and understand challenges, creating solutions while considering exceptions and criticisms."\n    },\n    {\n      "userId": 1,\n      "id": 2,\n      "title": "Understanding Identity",\n      "body": "Life\'s essence, measured through time, presents pains and joys. We find solace in the mundane, seeking meaning beyond the visible."\n    }\n  ]\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This command retrieves posts from the API, with each post containing a ",(0,t.jsx)(n.code,{children:"userId"})," field indicating its author."]}),"\n",(0,t.jsx)(n.p,{children:"Next, we fetch details for each post's author, such as:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:'\u276f curl https://jsonplaceholder.typicode.com/users/1\n  {\n    "id": 1,\n    "name": "Leanne Graham",\n    "username": "Bret",\n    "email": "Sincere@april.biz",\n    "address": {\n      "street": "Kulas Light",\n      "suite": "Apt. 556",\n      "city": "Gwenborough",\n      "zipcode": "92998-3874",\n      "geo": {\n        "lat": "-37.3159",\n        "lng": "81.1496"\n      }\n    },\n    "phone": "1-770-736-8031 x56442",\n    "website": "hildegard.org",\n    "company": {\n      "name": "Romaguera-Crona",\n      "catchPhrase": "Multi-layered client-server neural-net",\n      "bs": "harness real-time e-markets"\n    }\n  }\n'})}),"\n",(0,t.jsxs)(n.p,{children:["For 100 posts, this results in 100 additional requests for author details, totaling 101 requests. This is the infamous ",(0,t.jsx)(n.em,{children:"N + 1 problem"}),":"]}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["1 request for ",(0,t.jsx)(n.code,{children:"/posts"})]}),"\n",(0,t.jsxs)(n.li,{children:["100 or ",(0,t.jsx)(n.code,{children:"N"})," requests for ",(0,t.jsx)(n.code,{children:"/users/:id"})," for each user"]}),"\n"]}),"\n",(0,t.jsx)(n.admonition,{type:"info",children:(0,t.jsx)(n.p,{children:"This issue can escalate in real-world scenarios, leading to straining resources, increasing server costs, slowing response times, and potentially causing server downtime even at a moderate scale."})}),"\n",(0,t.jsx)(n.p,{children:"Hope this gives you a high-level overview of what the N + 1 problem is in the API context. It's a common problem not specific to just APIs or GraphQL, you will see this problem very commonly in database queries also. However addressing the N+1 problem during application design and development is crucial and we will see how this is tackled in Tailcall."}),"\n",(0,t.jsx)(n.h2,{id:"n--1-in-tailcall",children:"N + 1 in Tailcall"}),"\n",(0,t.jsx)(n.p,{children:"Before diving into solutions, let's observe the N+1 problem in the following Tailcall configuration:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",children:'schema\n  @upstream(\n    baseURL: "http://jsonplaceholder.typicode.com"\n  ) {\n  query: Query\n}\n\ntype Query {\n  posts: [Post] @http(path: "/posts")\n}\n\ntype Post {\n  id: Int!\n  userId: Int!\n  title: String!\n  body: String!\n  user: User @http(path: "/users/{{.value.userId}}")\n}\n\ntype User {\n  id: Int!\n  name: String!\n  username: String!\n  email: String!\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This configuration sets up a GraphQL schema for a Tailcall server utilizing ",(0,t.jsx)(n.a,{href:"https://jsonplaceholder.typicode.com/",children:"jsonplaceholder.typicode.com"})," as its data source. It allows direct querying of posts and, for each post, retrieves the associated author information. Similar to our curl requests above, when we query for posts and their authors we end up issuing multiple user calls upstream:"]}),"\n",(0,t.jsxs)(n.p,{children:["Let's examine the CLI output for this configuration with Tailcall's ",(0,t.jsx)(n.code,{children:"start"})," command:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",metastring:"{6-9}",children:"\u276f tailcall start ./examples/jsonplaceholder.graphql\n  INFO File read: ./examples/jsonplaceholder.graphql ... ok\n  INFO N + 1 detected: 1\n  INFO \ud83d\ude80 Tailcall launched at [0.0.0.0:8000] over HTTP/1.1\n  INFO \ud83c\udf0d Playground: https://tailcall.run/playground/?u=http://127.0.0.1:8000/graphql\n  INFO GET http://jsonplaceholder.typicode.com/posts HTTP/1.1\n  INFO GET http://jsonplaceholder.typicode.com/users/8 HTTP/1.1\n  ...\n  INFO GET http://jsonplaceholder.typicode.com/users/8 HTTP/1.1\n  INFO GET http://jsonplaceholder.typicode.com/users/10 HTTP/1.1\n"})}),"\n",(0,t.jsx)(n.p,{children:"Tailcall logs a sequence of requests made to fetch posts and then their individual authors, highlighting the N+1 problem in real-time. Since there are 100 posts, so 100 requests are made to fetch the authors."}),"\n",(0,t.jsx)(n.h2,{id:"automatic-deduplication",children:"Automatic Deduplication"}),"\n",(0,t.jsxs)(n.p,{children:["If you run the query, at first you will observe a lot of duplicate requests are being made for getting the same author details. This happens because of the 100 posts, a lot them are authored by the same user and by default Tailcall will make a request for every user when requested. You can fix this by setting ",(0,t.jsx)(n.a,{href:"/docs/directives/upstream#dedupe",children:"dedupe"})," to ",(0,t.jsx)(n.code,{children:"true"})," in ",(0,t.jsx)(n.a,{href:"/docs/directives/upstream",children:"upstream"}),"."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",metastring:"{4}",children:'schema\n  @upstream(\n    baseURL: "http://jsonplaceholder.typicode.com"\n    dedupe: true\n  ) {\n  query: Query\n}\n\ntype Query {\n  # ...\n}\n\ntype Post {\n  # ...\n}\n\ntype User {\n  # ...\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["When you enable ",(0,t.jsx)(n.code,{children:"dedupe"}),", for each downstream request, Tailcall will automatically deduplicate all upstream requests and instead of making 100 it will only make 10 requests for unique users:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",metastring:"{6-16}",children:"\u276f tailcall start ./examples/jsonplaceholder.graphql\n  INFO File read: ./examples/jsonplaceholder.graphql ... ok\n  INFO N + 1 detected: 1\n  INFO \ud83d\ude80 Tailcall launched at [0.0.0.0:8000] over HTTP/1.1\n  INFO \ud83c\udf0d Playground: https://tailcall.run/playground/?u=http://127.0.0.1:8000/graphql\n  INFO GET http://jsonplaceholder.typicode.com/posts HTTP/1.1\n  INFO GET http://jsonplaceholder.typicode.com/users/1 HTTP/1.1\n  INFO GET http://jsonplaceholder.typicode.com/users/2 HTTP/1.1\n  INFO GET http://jsonplaceholder.typicode.com/users/3 HTTP/1.1\n  INFO GET http://jsonplaceholder.typicode.com/users/4 HTTP/1.1\n  INFO GET http://jsonplaceholder.typicode.com/users/5 HTTP/1.1\n  INFO GET http://jsonplaceholder.typicode.com/users/6 HTTP/1.1\n  INFO GET http://jsonplaceholder.typicode.com/users/7 HTTP/1.1\n  INFO GET http://jsonplaceholder.typicode.com/users/8 HTTP/1.1\n  INFO GET http://jsonplaceholder.typicode.com/users/9 HTTP/1.1\n  INFO GET http://jsonplaceholder.typicode.com/users/10 HTTP/1.1\n"})}),"\n",(0,t.jsx)(n.p,{children:"This is a massive 10x improvement over the previous implementation. However, it might not always be the case. For eg: If all the posts are created by different users you might still end up making 100 requests upstream."}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsx)(n.p,{children:"Dedupe has a slight performance overhead so if your use case doesn't have any N + 1 issues, it might be worth keeping this setting disabled."})}),"\n",(0,t.jsx)(n.h2,{id:"compile-time-n--1-checks",children:"Compile Time N + 1 Checks"}),"\n",(0,t.jsx)(n.p,{children:"Before we get into the actual solution, if you observe closely the above logs Tailcall identified that there was one N + 1 issue, even before the requests were made:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",metastring:"{3}",children:"\u276f tailcall start ./examples/jsonplaceholder.graphql\n  INFO File read: ./examples/jsonplaceholder.graphql ... ok\n  INFO N + 1 detected: 1\n  INFO \ud83d\ude80 Tailcall launched at [0.0.0.0:8000] over HTTP/1.1\n  INFO \ud83c\udf0d Playground: https://tailcall.run/playground/?u=http://127.0.0.1:8000/graphql\n  INFO GET http://jsonplaceholder.typicode.com/posts HTTP/1.1\n  INFO GET http://jsonplaceholder.typicode.com/users/8 HTTP/1.1\n  ...\n  INFO GET http://jsonplaceholder.typicode.com/users/10 HTTP/1.1\n"})}),"\n",(0,t.jsxs)(n.p,{children:["To get a deeper understanding of what this N + 1 issue is, we can use the ",(0,t.jsx)(n.a,{href:"/docs/guides/cli#--n-plus-one-queries",children:"--n-plus-one-queries"})," parameter with the ",(0,t.jsx)(n.code,{children:"check"})," command:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",metastring:"{4,5}",children:"\u276f tailcall check ./jsonplaceholder.graphql --n-plus-one-queries\n  INFO File read: ./examples/jsonplaceholder.graphql ... ok\n  INFO Config ./examples/jsonplaceholder.graphql ... ok\n  INFO N + 1 detected: 1\n  query { posts { user } }\n"})}),"\n",(0,t.jsxs)(n.p,{children:["Incredible, isn't it? Tailcall has discovered that querying for posts followed by their users would result in N + 1 upstream calls. This represents a significant productivity gain, as you can now identify all such N + 1 issues upfront without resorting to complex profiling, tracing, or other runtime techniques. The ",(0,t.jsx)(n.code,{children:"check"})," command also identifies the minimal query that could lead to these N + 1 problems by performing semantic analysis of your configuration. With these powerful tools handy you can go about making extremely efficient GraphQL backends as we will see next:"]}),"\n",(0,t.jsx)(n.h2,{id:"leveraging-batch-apis",children:"Leveraging Batch APIs"}),"\n",(0,t.jsxs)(n.p,{children:["An effective technique to mitigate the N+1 problem is deduplicating similar requests, significantly reducing the number of server calls. We achieved it previously using the ",(0,t.jsx)(n.a,{href:"/docs/directives/upstream#dedupe",children:"dedupe"}),' setting. With Tailcall we can go one step further by giving hints about "batch APIs".']}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Batch APIs:"})," Are special APIs that allow us to query multiple things at once. In our case we can pass multiple user Ids as query params, to the ",(0,t.jsx)(n.code,{children:"/users"})," API to resolve many users at once:"]}),"\n",(0,t.jsx)(n.admonition,{type:"tip",children:(0,t.jsxs)(n.p,{children:["Try to hit ",(0,t.jsx)(n.a,{href:"https://jsonplaceholder.typicode.com/users?id=1&id=2",children:"/users?id=1&id=2"})]})}),"\n",(0,t.jsxs)(n.p,{children:["TailCall provides the capability to leverage ",(0,t.jsx)(n.em,{children:"Batch APIs"}),". To utilize this feature, edit the ",(0,t.jsx)(n.code,{children:"@http"})," directive on ",(0,t.jsx)(n.code,{children:"Post.user"})," field in your GraphQL schema as follows:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",metastring:"{9-10}",children:'type Post {\n  id: Int!\n  userId: Int!\n  title: String!\n  body: String!\n  user: User\n    @http(\n      path: "/users"\n      query: [{key: "id", value: "{{.value.userId}}"}]\n      batchKey: ["id"]\n    )\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The described changes introduce two significant tweaks to the ",(0,t.jsx)(n.code,{children:"@http"})," directive:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Addition of a query parameter:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",metastring:"{6}",children:'type Post {\n  # ...\n  user: User\n    @http(\n      path: "/users"\n      query: [{key: "id", value: "{{.value.userId}}"}]\n      batchKey: ["id"]\n    )\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This configuration generates a URL with the ",(0,t.jsx)(n.code,{children:"userId"})," from the ",(0,t.jsx)(n.code,{children:"Post"})," in the query params. For a batch of users, the CLI compiles a single URL, such as ",(0,t.jsx)(n.code,{children:"/users?id=1&id=2&id=3...id=10"}),", consolidating the 10 requests into one."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.strong,{children:"Addition of a batchKey:"})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",metastring:"{7}",children:'type Post {\n  # ...\n  user: User\n    @http(\n      path: "/users"\n      query: [{key: "id", value: "{{.value.userId}}"}]\n      batchKey: ["id"]\n    )\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["This parameter instructs the system to use the user's ",(0,t.jsx)(n.code,{children:"id"}),", in the ",(0,t.jsx)(n.code,{children:"User"})," type, as the unique identifier. This helps in differentiating between users received from the batch API."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Let's see what the server logs when you now start Tailcall with the updated configuration:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-graphql",metastring:"{21-22}",children:'schema\n  @server(port: 8000)\n  @upstream(\n    baseURL: "http://jsonplaceholder.typicode.com"\n  ) {\n  query: Query\n}\n\ntype Query {\n  posts: [Post] @http(path: "/posts")\n}\n\ntype Post {\n  id: Int!\n  userId: Int!\n  title: String!\n  body: String!\n  user: User\n    @http(\n      path: "/users"\n      query: [{key: "id", value: "{{.value.userId}}"}]\n      batchKey: ["id"]\n    )\n}\n\ntype User {\n  id: Int!\n  name: String!\n  username: String!\n  email: String!\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"Let's start the server as usual and focus on the detected N + 1 issues:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-text",metastring:"{3,7}",children:"\u276f tailcall start ./examples/jsonplaceholder.graphql\n  INFO File read: ./examples/jsonplaceholder.graphql ... ok\n  INFO N + 1 detected: 0\n  INFO \ud83d\ude80 Tailcall launched at [0.0.0.0:8000] over HTTP/1.1\n  INFO \ud83c\udf0d Playground: https://tailcall.run/playground/?u=http://127.0.0.1:8000/graphql\n  INFO GET http://jsonplaceholder.typicode.com/posts HTTP/1.1\n  INFO GET http://jsonplaceholder.typicode.com/users?id=1&id=10&id=2&id=3&id=4&id=5&id=6&id=7&id=8&id=9 HTTP/1.1\n"})}),"\n",(0,t.jsx)(n.p,{children:"As you can see there are ZERO N + 1 detected this time! It basically means that irrespective of how large the list of posts is there is a finite number of requests that will be issued in this case that's always going to be TWO. And this is how Tailcall users tackle the N + 1 problem in GraphQL."}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsxs)(n.p,{children:["To summarize, we learnt that N + 1 is a general problem and not specific to GraphQL. It's a hard problem to identify, and developers often resort to runtime analysis to find such scenarios. N + 1 can really strain your infrastructure, leading to serious downtime in certain cases. We also learnt that in Tailcall, the CLI can introspect your configuration and identify all the potential N + 1 issues upfront. Using ",(0,t.jsx)(n.code,{children:"dedupe"}),", you can improve the N + 1 problem significantly, however, it's not a complete solution. To completely eliminate the N + 1 problem, you can configure Tailcall to leverage Batch APIs. Hopefully, this guide underscores the effectiveness of Tailcall in addressing the N + 1 problem."]})]})}function h(e={}){const{wrapper:n}={...(0,i.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},1151:(e,n,s)=>{s.d(n,{Z:()=>l,a:()=>a});var t=s(7294);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);
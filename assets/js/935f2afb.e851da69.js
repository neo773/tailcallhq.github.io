"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[8581],{5610:e=>{e.exports=JSON.parse('{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"docs":[{"type":"link","label":"Why Tailcall?","href":"/docs/","docId":"introduction","unlisted":false},{"type":"category","label":"Usage","items":[{"type":"link","label":"Getting Started","href":"/docs/getting-started-with-graphql","docId":"getting-started","unlisted":false},{"type":"link","label":"Command Line","href":"/docs/tailcall-graphql-cli","docId":"cli","unlisted":false},{"type":"link","label":"Configuration","href":"/docs/tailcall-dsl-graphql-custom-directives","docId":"directives","unlisted":false},{"type":"link","label":"Resolver Context","href":"/docs/graphql-resolver-context-tailcall","docId":"context","unlisted":false},{"type":"link","label":"GraphQL Playground","href":"/docs/graphql-playground-guide","docId":"playground","unlisted":false},{"type":"link","label":"Best Practices","href":"/docs/graphql-best-practices-tailcall","docId":"conventions","unlisted":false},{"type":"link","label":"Sequence vs Parallel","href":"/docs/graphql-data-access-parallel-vs-sequence","docId":"execution-strategy","unlisted":false},{"type":"link","label":"Watch Mode","href":"/docs/graphql-watch-mode-tailcall","docId":"watch-mode","unlisted":false}],"collapsed":false,"collapsible":false},{"type":"category","label":"Features","items":[{"type":"link","label":"N+1 Identification","href":"/docs/graphql-n-plus-one-problem-solved-tailcall","docId":"N+1","unlisted":false},{"type":"link","label":"Authentication","href":"/docs/field-level-access-control-graphql-authentication","docId":"auth","unlisted":false},{"type":"link","label":"GraphQL on gRPC","href":"/docs/graphql-grpc-tailcall","docId":"grpc","unlisted":false},{"type":"link","label":"Custom Resolvers","href":"/docs/graphql-javascript-customization","docId":"scripting","unlisted":false},{"type":"link","label":"HTTP/2","href":"/docs/graphql-http2-guide-tailcall","docId":"http2","unlisted":false},{"type":"link","label":"Telemetry","href":"/docs/graphql-telemetry-guide","docId":"telemetry","unlisted":false},{"type":"link","label":"HTTP Cache","href":"/docs/graphql-http-cache-guide-tailcall","docId":"http-cache","unlisted":false},{"type":"link","label":"Log Levels","href":"/docs/graphql-logging-levels-tailcall","docId":"logging","unlisted":false},{"type":"link","label":"REST on GraphQL","href":"/docs/graphql-rest-integration","docId":"rest","unlisted":false},{"type":"link","label":"GraphQL Scalars","href":"/docs/graphql-scalars-guide","docId":"scalar","unlisted":false},{"type":"link","label":"Environment Variables","href":"/docs/graphql-environment-variables","docId":"environment-variables","unlisted":false},{"type":"link","label":"Configuration Formats","href":"/docs/tailcall-graphql-configuration-format-conversion","docId":"configuration","unlisted":false}],"collapsed":false,"collapsible":false},{"type":"category","label":"Integrations","items":[{"type":"link","label":"Apollo Studio","href":"/docs/integrate-apollo-studio-graphql-tailcall","docId":"apollo-studio","unlisted":false},{"type":"link","label":"Data Dog","href":"/docs/graphql-data-dog-telemetry-tailcall","docId":"data-dog","unlisted":false},{"type":"link","label":"New Relic","href":"/docs/graphql-newrelic-guide-telemetry","docId":"new-relic","unlisted":false},{"type":"link","label":"Honeycomb","href":"/docs/graphql-honeycomb-telemetry-tailcall","docId":"honey-comb","unlisted":false}],"collapsed":false,"collapsible":false},{"type":"category","label":"Production","items":[{"type":"link","label":"Tailcall on AWS","href":"/docs/graphql-aws-deployment-tailcall","docId":"tailcall-on-aws","unlisted":false},{"type":"link","label":"Performance Tuning","href":"/docs/graphql-client-performance-tuning","docId":"client-tuning","unlisted":false}],"collapsed":false,"collapsible":false}]},"docs":{"apollo-studio":{"id":"apollo-studio","title":"Integrating Tailcall with Apollo Studio","description":"Enhance your GraphQL server\'s efficiency by integrating Tailcall with Apollo Studio using our concise guide. Learn how to configure Tailcall to send vital usage metrics to Apollo Studio for advanced performance monitoring and optimization. Whether you\'re establishing a Monolith graph or improving an existing one, our instructions facilitate seamless integration. Set up for better insights and leverage Apollo Studio\'s features for a more responsive GraphQL server. Start optimizing today with our straightforward steps and explore Apollo Studio\'s free trial for new users.","sidebar":"docs"},"auth":{"id":"auth","title":"Field Level GraphQL Authentication","description":"Discover how to provide granular access to types and fields in your GraphQL schema using authentication providers. Our guide helps you enhance security and control by configuring precise access levels within your GraphQL server. Start implementing advanced access control measures today.","sidebar":"docs"},"cli":{"id":"cli","title":"Command Line Reference","description":"Discover the TailCall CLI, a crucial tool for developers to manage and optimize GraphQL configurations from the command line. Learn commands like \'check\', \'start\', \'init\', and \'gen\' to validate specs, launch servers, bootstrap projects, and generate configurations. Detect N+1 issues, display schemas, format inputs, and more. Simplify GraphQL composition and enhance your development workflow with TailCall CLI.","sidebar":"docs"},"client-tuning":{"id":"client-tuning","title":"Optimizing Performance of your GraphQL Server","description":"Learn how to tune your client for optimal performance. Our guide provides essential tips and techniques to enhance responsiveness and efficiency in your applications. Start optimizing your client today for a faster, smoother user experience.","sidebar":"docs"},"configuration":{"id":"configuration","title":"GraphQL Configuration Formats","description":"Explore the format conversion capabilities of the Tailcall CLI, supporting GraphQL, YAML, and JSON for configuration files. This documentation shows developers how to effortlessly convert and manage configurations, leveraging GraphQL for clear type definitions, and YAML and JSON for their ubiquity in tools and API integration. Enhance your development and deployment workflows today.","sidebar":"docs"},"context":{"id":"context","title":"GraphQL Resolver Context","description":"Explore Tailcall\'s dynamic Context mechanism for schema field resolution, enabling access to arguments, values, and environment variables for efficient GraphQL queries. Enhance your query handling with Tailcall\'s advanced Context features for optimized schema field resolution.","sidebar":"docs"},"conventions":{"id":"conventions","title":"GraphQL Best Practices","description":"Enhance your understanding of naming and casing conventions for GraphQL schema to ensure clarity and consistency in your schema design using Tailcall. Learn best practices for naming to maintain a well-structured and readable GraphQL schema.","sidebar":"docs"},"data-dog":{"id":"data-dog","title":"Data Dog Telemetry Integration","description":"Discover how to enhance application performance with our guide on enabling and analyzing telemetry data in Tailcall. Learn to configure observability support using OpenTelemetry for insights into logs, metrics, and traces, with practical integration examples for platforms like Honeycomb.io, New Relic, and Datadog.","sidebar":"docs"},"directives":{"id":"directives","title":"GraphQL Configuration","description":"Enhance your GraphQL API with Tailcall DSL\'s custom directives. These directives offer powerful compile-time guarantees, ensuring robust and optimized API composition. Tailcall automates the generation of resolver logic for improved performance.","sidebar":"docs"},"environment-variables":{"id":"environment-variables","title":"Reading Environment Variables","description":"Learn how to effectively manage environment variables in your Tailcall GraphQL schema, enhancing security and flexibility in your application configuration. This guide explores the need for environment variables, their implementation in Tailcall schemas, and best practices for security and management.","sidebar":"docs"},"execution-strategy":{"id":"execution-strategy","title":"Sequencing & Parallelism","description":"Tailcall revolutionizes data access layer development by automating API call orchestration, ensuring optimal execution strategies through advanced sequencing and parallelism techniques.","sidebar":"docs"},"getting-started":{"id":"getting-started","title":"Getting Started with GraphQL","description":"Discover how to efficiently get started with GraphQL using Tailcall, enhancing your data access capabilities through optimized execution strategies.","sidebar":"docs"},"grpc":{"id":"grpc","title":"GraphQL on gRPC","description":"Discover how to integrate gRPC services with Tailcall\'s GraphQL gateway in this comprehensive guide. Learn about the benefits of using gRPC, a high-performance framework by Google, for efficient data transfer in microservices and distributed systems. Understand how to set up simple gRPC services, define protobuf files, and implement a gRPC server. Explore how to configure Tailcall to seamlessly connect GraphQL types to gRPC types, enabling advanced features like batching and reflection for dynamic service discovery. Perfect for developers with a basic understanding of gRPC, this guide will help you enhance your system\'s capability to handle high-performance data operations with simplicity and scalability.","sidebar":"docs"},"honey-comb":{"id":"honey-comb","title":"Honeycomb Telemetry Integration","description":"Enhance your application\'s performance with our guide on enabling and analyzing telemetry data in Tailcall. Learn how to configure observability support using OpenTelemetry for comprehensive insights into logs, metrics, and traces. This guide includes practical integration examples for platforms such as Honeycomb.io, New Relic, and Datadog.","sidebar":"docs"},"http-cache":{"id":"http-cache","title":"Using HTTP Cache","description":"A comprehensive guide to leverage HTTP cache for REST APIs using Tailcall.","sidebar":"docs"},"http2":{"id":"http2","title":"GraphQL over HTTP/2","description":"Boost web performance and secure your communications by utilizing HTTP/2 with Tailcall GraphQL.","sidebar":"docs"},"introduction":{"id":"introduction","title":"Why should you use Tailcall?","description":"Welcome to Tailcall! Discover the features and benefits of using Tailcall for optimizing and managing your GraphQL server configurations. This introduction provides an overview of Tailcall\'s capabilities, guiding you through its essential tools and functionalities to enhance your GraphQL development and performance.","sidebar":"docs"},"logging":{"id":"logging","title":"Logging Levels Configuration","description":"Learn how to configure log levels in Tailcall to obtain insights into code execution and address software development challenges. Discover the available log levels, set verbosity via environment variables, and understand the hierarchy of log levels for effective logging.","sidebar":"docs"},"N+1":{"id":"N+1","title":"Solving the N+1 Issue with Tailcall","description":"Discover Tailcall\'s powerful introspection capabilities for tackling the N+1 problem, a common performance issue where a single downstream request triggers numerous upstream requests. Tailcall helps you identify N+1 issues before starting your server, ensuring optimal performance and efficiency. Learn how Tailcall enhances your system\'s functionality by addressing this critical challenge.","sidebar":"docs"},"new-relic":{"id":"new-relic","title":"New Relic Telemetry Integration","description":"Discover how to enhance application performance with our guide on enabling and analyzing telemetry data in Tailcall. Learn to configure observability support using OpenTelemetry for insights into logs, metrics, and traces, with practical integration examples for platforms like Honeycomb.io, New Relic, and Datadog.","sidebar":"docs"},"playground":{"id":"playground","title":"GraphQL Playground","description":"Explore and test server configurations with the @server directive\'s showcase feature in a controlled environment. Ideal for quick experimentation and learning with dynamic GraphQL schema configurations. Not recommended for production due to performance and security considerations.","sidebar":"docs"},"rest":{"id":"rest","title":"Exposing GraphQL as REST APIs","description":"Exposing REST endpoints on top of GraphQL via the @rest directive.","sidebar":"docs"},"scalar":{"id":"scalar","title":"Simplifying GraphQL Scalars","description":"Explore GraphQL\'s core and Tailcall\'s custom scalars, including `Int`, `Float`, `String`, `Boolean`, `ID`, `Email`, and more, in our guide that simplifies data handling with clear definitions and examples. Enhance your applications with our comprehensive scalar support, designed for precise data validation and efficiency.","sidebar":"docs"},"scripting":{"id":"scripting","title":"Customizing using Javascript","description":"Discover how to effortlessly manipulate HTTP requests and responses using Tailcall\'s lightweight JS runtime. Tailcall provides a streamlined JavaScript environment specifically designed for simple yet powerful request/response modifications without the complexity of a full Node.js setup. Ideal for developers looking to implement middleware solutions, Tailcall\'s runtime does not require file system or network access, ensuring a secure and focused development process.","sidebar":"docs"},"tailcall-on-aws":{"id":"tailcall-on-aws","title":"Tailcall on AWS","description":"Deploy Tailcall on AWS effortlessly using the tailcall-on-aws template and Terraform. This guide covers everything from setting environment variables to configuring and updating your Tailcall deployment, complete with logging via AWS CloudWatch for comprehensive monitoring and management.","sidebar":"docs"},"telemetry":{"id":"telemetry","title":"GraphQL Telemetry","description":"Learn how to configure observability support using OpenTelemetry for insights into logs, metrics, and traces. Discover practical integration examples for platforms like Honeycomb.io, New Relic, and Datadog.","sidebar":"docs"},"watch-mode":{"id":"watch-mode","title":"GraphQL Server Watch Mode","description":"Learn how to enhance your development workflow by running servers in watch mode with the versatile file-watcher tool, entr. This guide provides installation instructions for different operating systems, usage tips, and best practices to optimize your development process.","sidebar":"docs"}}}')}}]);